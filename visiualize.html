<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>几何图形可视化</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        button {
            margin: 5px;
            padding: 8px 15px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #777;
        }
        button.active {
            background: #0066cc;
        }
    </style>
</head>
<body>
    <div id="info">加载中...</div>

    
    <script type='importmap'>
    {
        "imports": {
            "three": "./node_modules/three/build/three.module.js",
            "three/addons/": "./node_modules/three/examples/jsm/",
            "three-mesh-bvh": "./node_modules/three-mesh-bvh/build/index.module.js",
            "three-bvh-csg": "./node_modules/three-bvh-csg/build/index.module.js"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // 导入CSG库用于真正的布尔运算
        import { SUBTRACTION, ADDITION, Brush, Evaluator } from 'three-bvh-csg';
        
        // 导入墙体选择器
        import {createSingleWallFace, createWallsFromPoints} from './Face.js'
        import { WallClickSelector } from './wall-click-selector.js'

        
        // 全局变量
        let wallSelector = null;
        let wallGroupSelector = null;
        let currentMesh = null;
        let currentSelectorType = 'basic';
        let roomsDataCache = null;
        
        // 墙面点击选择器
        let wallClickSelector = null;
        
        // 分析房间墙面段（区分弧形和直线）
        function analyzeRoomWallSegments(roomPoints) {
            const segments = [];
            let i = 0;
            
            while (i < roomPoints.length) {
                const currentPoint = roomPoints[i];
                
                // 验证点数据格式
                if (!Array.isArray(currentPoint) || currentPoint.length < 4) {
                    console.error(`点 ${i} 数据格式错误:`, currentPoint);
                    i++;
                    continue;
                }
                
                // 检查坐标值有效性
                if (isNaN(currentPoint[0]) || isNaN(currentPoint[1]) || isNaN(currentPoint[3])) {
                    console.error(`点 ${i} 包含无效数值:`, currentPoint);
                    i++;
                    continue;
                }
                
                const bulge = currentPoint[3]; // 第4个元素是bulge值
                
                if (Math.abs(bulge) > 0.001) {
                    // 这是弧形点的开始，收集整个弧形段
                    const arcPoints = [currentPoint];
                    let j = i + 1;
                    
                    // 继续收集弧形点，直到遇到bulge为0的点
                    while (j < roomPoints.length) {
                        const nextPoint = roomPoints[j];
                        
                        if (!Array.isArray(nextPoint) || nextPoint.length < 4) {
                            console.error(`弧形段中点 ${j} 数据格式错误:`, nextPoint);
                            break;
                        }
                        
                        arcPoints.push(nextPoint);
                        
                        // 如果下一个点的bulge为0，说明弧形段结束
                        if (Math.abs(nextPoint[3]) <= 0.001) {
                            break;
                        }
                        
                        j++;
                    }
                    
                    // 创建弧形段
                    segments.push({
                        type: 'arc',
                        points: arcPoints.map(point => [point[0], point[1], point[2] || 0]), // 只保留xyz坐标
                        startIndex: i,
                        endIndex: j,
                        pointCount: arcPoints.length
                    });
                    
                    console.log(`识别弧形段: 点 ${i} 到 ${j}, 共 ${arcPoints.length} 个点`);
                    i = j + 1; // 跳过已处理的弧形点
                    
                } else {
                    // 这是直线点，创建到下一个点的直线段
                    const nextIndex = (i + 1) % roomPoints.length;
                    const nextPoint = roomPoints[nextIndex];
                    
                    if (Array.isArray(nextPoint) && nextPoint.length >= 2) {
                        segments.push({
                            type: 'line',
                            startPoint: [currentPoint[0], currentPoint[1], currentPoint[2] || 0],
                            endPoint: [nextPoint[0], nextPoint[1], nextPoint[2] || 0],
                            startIndex: i,
                            endIndex: nextIndex
                        });
                        
                        console.log(`识别直线段: 点 ${i} (${currentPoint[0].toFixed(2)}, ${currentPoint[1].toFixed(2)}) 到点 ${nextIndex} (${nextPoint[0].toFixed(2)}, ${nextPoint[1].toFixed(2)})`);
                    }
                    
                    i++;
                }
            }
            
            console.log(`房间分析完成，共识别 ${segments.length} 个墙面段`);
            return segments;
        }
        
        // CSG布尔运算实现类
        class CSGOperations {
            static subtract(meshA, meshB) {
                try {
                    if (!meshA || !meshB || !meshA.geometry || !meshB.geometry) {
                        throw new Error("输入几何体无效");
                    }
                    
                    const evaluator = new Evaluator();
                    const brushA = new Brush(meshA.geometry);
                    const brushB = new Brush(meshB.geometry);
                    
                    const targetBrush = new Brush();
                    evaluator.evaluate(brushA, brushB, SUBTRACTION, targetBrush);
                    
                    if (targetBrush.geometry && targetBrush.geometry.attributes.position.count > 0) {
                        const resultMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xffffff,
                            side: THREE.DoubleSide
                        });
                        
                        return new THREE.Mesh(targetBrush.geometry, resultMaterial);
                    } else {
                        throw new Error("CSG运算返回空几何体");
                    }
                    
                } catch (error) {
                    console.error("CSG减法失败:", error);
                    
                    // 降级方案：显示半透明组合
                    const group = new THREE.Group();
                    
                    meshA.material = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    group.add(meshA);
                    
                    meshB.material = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.3,
                        wireframe: true
                    });
                    group.add(meshB);
                    
                    return group;
                }
            }
            
            static union(meshA, meshB) {
                try {
                    if (!meshA || !meshB || !meshA.geometry || !meshB.geometry) {
                        throw new Error("输入几何体无效");
                    }
                    
                    const evaluator = new Evaluator();
                    const brushA = new Brush(meshA.geometry);
                    const brushB = new Brush(meshB.geometry);
                    
                    const targetBrush = new Brush();
                    evaluator.evaluate(brushA, brushB, ADDITION, targetBrush);
                    
                    if (targetBrush.geometry && targetBrush.geometry.attributes.position.count > 0) {
                        const resultMaterial = meshA.material.clone();
                        return new THREE.Mesh(targetBrush.geometry, resultMaterial);
                    } else {
                        throw new Error("CSG并集运算返回空几何体");
                    }
                    
                } catch (error) {
                    console.error("CSG并集失败:", error);
                    
                    // 降级方案：简单组合
                    const group = new THREE.Group();
                    group.add(meshA);
                    group.add(meshB);
                    return group;
                }
            }
        }

        // 初始化Three.js场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 200);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x333333);
        document.body.appendChild(renderer.domElement);

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // 添加坐标轴辅助器
        const axesHelper = new THREE.AxesHelper(50);
        scene.add(axesHelper);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 从服务器获取数据
        async function fetchData(query) {
            try {
                document.getElementById('info').textContent = '正在获取数据...';
                
                // 注意端口号要与main.js中设置的一致
                let resp = await fetch(`http://localhost:4001/${query}`);
                
                if (!resp.ok) {
                    throw new Error(`HTTP error! status: ${resp.status}`);
                }
                
                let data = await resp.json();
                document.getElementById('info').textContent = '数据加载完成';
                return data;
            } catch (error) {
                console.error('获取数据失败:', error);
                document.getElementById('info').textContent = '数据加载失败: ' + error.message;
                return null;
            }
        }


        // 全局缩放参数，确保所有几何体使用相同的缩放
        let globalScale = 1;
        let globalCenterX = 0;
        let globalCenterY = 0;
        let isGlobalScaleSet = false;
        
        // 创建几何体
        function createMeshFromPoints(points, color = 0xffffff, isWireframe = false) {
            if (!points || points.length < 3) {
                return null;
            }

            // 数据格式转换：[[x,y,z], ...] -> [{x,y}, ...]
            let convertedPoints = [];
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            // 转换数据格式并计算边界
            for (let point of points) {
                let x, y;
                if (Array.isArray(point) && point.length >= 2) {
                    x = point[0];
                    y = point[1];
                } else if (typeof point === 'object' && point.x !== undefined) {
                    x = point.x;
                    y = point.y;
                } else {
                    console.error("无效的点格式:", point);
                    continue;
                }
                
                convertedPoints.push({x, y});
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            
            // 设置全局缩放参数（只在第一次调用时设置）
            if (!isGlobalScaleSet) {
                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const maxSize = Math.max(sizeX, sizeY);
                globalScale = maxSize > 0 ? 100 / maxSize : 1;
                globalCenterX = (minX + maxX) / 2;
                globalCenterY = (minY + maxY) / 2;
                isGlobalScaleSet = true;
            }
            
            // 创建 Shape
            const shape = new THREE.Shape();
            
            // 使用全局缩放参数
            const firstPoint = convertedPoints[0];
            const scaledX = (firstPoint.x - globalCenterX) * globalScale;
            const scaledY = (firstPoint.y - globalCenterY) * globalScale;
            shape.moveTo(scaledX, scaledY);
            
            // 添加其他点
            for (let i = 1; i < convertedPoints.length; i++) {
                const point = convertedPoints[i];
                const x = (point.x - globalCenterX) * globalScale;
                const y = (point.y - globalCenterY) * globalScale;
                shape.lineTo(x, y);
            }
            
            // 确保形状闭合
            shape.lineTo(scaledX, scaledY);
            
            const extrudeSettings = {
                steps: 1, // 减少步数，提高CSG性能
                depth: 10, // 统一深度
                bevelEnabled: false,
                UVGenerator: THREE.ExtrudeGeometry.WorldUVGenerator // 添加UV生成器
            };

            try {
                const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                
                // 确保几何体是合法的，便于CSG运算
                geometry.computeVertexNormals();
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();
                
                const material = new THREE.MeshLambertMaterial({ 
                    color: color,
                    side: THREE.DoubleSide,
                    wireframe: isWireframe,
                    transparent: isWireframe,
                    opacity: isWireframe ? 0.3 : 1.0
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.updateMatrixWorld();
                
                return mesh;
                
            } catch (error) {
                return null;
            }
        }
        
        // 备选方案：创建线框
        function createWireframeFromPoints(points, centerX, centerY, scale) {
            const linePoints = [];
            
            for (let point of points) {
                const x = (point.x - centerX) * scale;
                const y = (point.y - centerY) * scale;
                linePoints.push(new THREE.Vector3(x, y, 0));
            }
            
            // 闭合线条
            if (linePoints.length > 0) {
                linePoints.push(linePoints[0].clone());
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            
            return new THREE.Line(geometry, material);
        }






        // 主函数
        async function main() {
            let outlineMesh = null;
            let roomMeshes = [];
            
            // 初始化墙面点击选择器
            wallClickSelector = new WallClickSelector(scene, camera, renderer);
            
            try {
                // 1. 获取外轮廓数据
                document.getElementById('info').textContent = '正在获取外轮廓数据...';
                const outline = await fetchData("outline");
                
                if (outline && outline.success) {
                    if (!outline.outlinePoints || outline.outlinePoints.length < 3) {
                        throw new Error('外轮廓点数据无效或不足');
                    }
                    
                    document.getElementById('info').textContent = '正在创建外轮廓几何体...';
                    
                    // 创建外轮廓几何体（绿色）
                    outlineMesh = createMeshFromPoints(outline.outlinePoints, 0x00ff00, false);
                    
                    if (!outlineMesh) {
                        throw new Error('外轮廓几何体创建失败');
                    }
                } else {
                    throw new Error('外轮廓数据获取失败或格式错误');
                }
                
                // 2. 获取房间数据
                document.getElementById('info').textContent = '正在获取房间数据...';
                const rooms = await fetchData("rooms");
                
                if (rooms && rooms.success && rooms.roomPoints) {
                    document.getElementById('info').textContent = '正在创建房间几何体...';
                    
                    // 缓存房间数据供分组选择器使用
                    roomsDataCache = rooms;
                    
                    // 创建每个房间的几何体（红色）
                    for (let i = 0; i < rooms.roomPoints.length; i++) {
                        const roomMesh = createMeshFromPoints(rooms.roomPoints[i], 0xff0000, true);
                        if (roomMesh) {
                            roomMeshes.push(roomMesh);
                        }
                    }
                }
                
                // 3. 执行布尔运算（挖洞）
                if (outlineMesh && roomMeshes.length > 0) {
                    document.getElementById('info').textContent = `正在执行布尔运算，挖去${roomMeshes.length}个房间...`;
                    
                    // 将所有房间合并成一个几何体
                    let combinedRooms = roomMeshes[0];
                    
                    for (let i = 1; i < roomMeshes.length; i++) {
                        combinedRooms = CSGOperations.union(combinedRooms, roomMeshes[i]);
                        
                        if (!combinedRooms) {
                            break;
                        }
                    }
                    
                    if (combinedRooms) {
                        // 从外轮廓中挖去所有房间
                        const finalMesh = CSGOperations.subtract(outlineMesh, combinedRooms);
                        
                        if (finalMesh) {
                            scene.add(finalMesh);
                            currentMesh = finalMesh;
                            
                            
                            
                            document.getElementById('info').textContent = `挖洞完成 - 户型已挖去${roomMeshes.length}个房间。`;
                        } else {
                            // 降级显示原始几何体
                            scene.add(outlineMesh);
                            roomMeshes.forEach(mesh => scene.add(mesh));
                            document.getElementById('info').textContent = `挖洞失败 - 显示原始几何体`;
                        }
                    } else {
                        // 降级显示
                        scene.add(outlineMesh);
                        roomMeshes.forEach(mesh => scene.add(mesh));
                        document.getElementById('info').textContent = `房间合并失败 - 显示原始几何体`;
                    }
                    
                } else if (outlineMesh) {
                    // 如果没有房间数据，只显示外轮廓
                    scene.add(outlineMesh);
                    document.getElementById('info').textContent = '渲染完成 - 仅显示外轮廓（无房间数据）';
                } else {
                    throw new Error('无有效几何体可显示');
                }


                // 根据房间wire创建墙面（支持弧形墙面）
                if (rooms && rooms.roomPoints && rooms.roomPoints.length > 0) {
                    console.log('开始创建房间墙面，房间数量:', rooms.roomPoints.length);
                    console.log('全局变换参数:', { globalScale, globalCenterX, globalCenterY, isGlobalScaleSet });
                    
                    for (let i = 0; i < rooms.roomPoints.length; i++) {
                        const roomPoints = rooms.roomPoints[i];
                        console.log(`房间 ${i} 的点数据:`, roomPoints);
                        
                        // 分析并创建墙面段
                        const wallSegments = analyzeRoomWallSegments(roomPoints);
                        console.log(`房间 ${i} 识别到 ${wallSegments.length} 个墙面段:`, wallSegments);
                        
                        // 为每个墙面段创建墙面
                        wallSegments.forEach((segment, segmentIndex) => {
                            const wallHeight = 10; // 与户型图厚度保持一致
                            
                            if (segment.type === 'arc') {
                                // 弧形墙面：使用createWallsFromPoints
                                console.log(`创建弧形墙面 ${segmentIndex}:`, segment.points.length, '个点');
                                
                                // 转换弧形点坐标
                                const scaledArcPoints = segment.points.map(point => {
                                    const scaledX = (point[0] - globalCenterX) * globalScale;
                                    const scaledY = (point[1] - globalCenterY) * globalScale;
                                    return [scaledX, scaledY, 0];
                                });
                                
                                const arcWallGroup = createWallsFromPoints(scaledArcPoints, 0x00ff88, wallHeight, false);
                                if (arcWallGroup) {
                                    // 为弧形墙group添加标识信息
                                    arcWallGroup.userData.isArcWall = true;
                                    arcWallGroup.userData.roomIndex = i;
                                    arcWallGroup.userData.segmentIndex = segmentIndex;
                                    arcWallGroup.userData.wallType = 'arc';
                                    
                                    scene.add(arcWallGroup);
                                    
                                    // 将弧形墙面组中的所有子墙面添加到选择器，并为每个子墙面添加parent引用
                                    arcWallGroup.children.forEach(childWall => {
                                        childWall.userData.parentArcWall = arcWallGroup;
                                        childWall.userData.isArcWallPart = true;
                                        wallClickSelector.addWallMesh(childWall);
                                    });
                                }
                                
                            } else {
                                // 直线墙面：使用createSingleWallFace
                                console.log(`创建直线墙面 ${segmentIndex}:`, segment.startPoint, '->', segment.endPoint);
                                
                                // 转换直线点坐标
                                const scaledX1 = (segment.startPoint[0] - globalCenterX) * globalScale;
                                const scaledY1 = (segment.startPoint[1] - globalCenterY) * globalScale;
                                const scaledX2 = (segment.endPoint[0] - globalCenterX) * globalScale;
                                const scaledY2 = (segment.endPoint[1] - globalCenterY) * globalScale;
                                
                                const point1 = [scaledX1, scaledY1, 0];
                                const point2 = [scaledX2, scaledY2, 0];
                                
                                const wallFace = createSingleWallFace([point1, point2], 0xffffff, wallHeight);
                                
                                if (wallFace) {
                                    scene.add(wallFace);
                                    wallClickSelector.addWallMesh(wallFace);
                                }
                            }
                        });
                    }
                } else {
                    console.log('没有房间数据，跳过墙面创建');
                }
                

                
                // 4. 调整相机位置
                camera.position.set(0, 0, 150);
                controls.target.set(0, 0, 0);
                controls.update();
                
            } catch (error) {
                console.error('主函数执行失败:', error);
                document.getElementById('info').textContent = '渲染失败: ' + error.message;
            }
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }


        // 启动应用
        main();
        animate();
    </script>
</body>
</html>